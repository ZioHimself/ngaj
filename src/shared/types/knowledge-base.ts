/**
 * Knowledge Base Type Definitions
 * 
 * These types support the Knowledge Base feature which enables users to upload
 * reference materials (PDFs, Markdown, TXT files) that ground AI-generated responses.
 * 
 * @see {@link ../../../docs/architecture/decisions/007-knowledge-base-implementation.md} - Design rationale
 * @see {@link ../../../.agents/artifacts/designer/designs/knowledge-base-design.md} - Complete technical specification
 */

/**
 * Represents an uploaded knowledge base document with processing metadata.
 * Stored in MongoDB `knowledge_documents` collection.
 */
export interface KnowledgeDocument {
  /**
   * Unique identifier for the document
   * Format: UUID v4
   */
  id: string;

  /**
   * Profile that owns this document
   * References profiles.id
   */
  profileId: string;

  /**
   * Original filename as uploaded by user
   * Example: "my-research-paper.pdf"
   */
  filename: string;

  /**
   * File size in bytes
   */
  fileSizeBytes: number;

  /**
   * MIME type of uploaded file
   * Allowed values: "application/pdf", "text/markdown", "text/plain"
   */
  mimeType: 'application/pdf' | 'text/markdown' | 'text/plain';

  /**
   * Absolute filesystem path to stored file
   * Format: {storageRoot}/knowledge/{profileId}/{id}/original.{ext}
   */
  filePath: string;

  /**
   * Timestamp when document was uploaded
   */
  uploadedAt: Date;

  /**
   * Number of chunks created from this document
   * Used for deletion (must delete all chunks from ChromaDB)
   */
  chunkCount: number;

  /**
   * Total character count of extracted text
   */
  characterCount: number;

  /**
   * ChromaDB collection name where chunks are stored
   * Format: profile_{profileId}_kb
   */
  chromaCollection: string;

  /**
   * Processing metadata (for observability and debugging)
   */
  processingMetadata: KnowledgeDocumentProcessingMetadata;
}

/**
 * Processing metadata for knowledge document
 */
export interface KnowledgeDocumentProcessingMetadata {
  /**
   * Time taken to extract text (milliseconds)
   */
  extractionTimeMs: number;

  /**
   * Time taken to chunk text (milliseconds)
   */
  chunkingTimeMs: number;

  /**
   * Time taken to generate embeddings (milliseconds)
   */
  embeddingTimeMs: number;

  /**
   * Total processing time (milliseconds)
   */
  totalTimeMs: number;
}

/**
 * Represents a semantic chunk of a document stored in ChromaDB.
 * Each chunk has an embedding vector for similarity search.
 */
export interface DocumentChunk {
  /**
   * Unique identifier for the chunk
   * Format: {documentId}_chunk_{index}
   * Example: "abc-123_chunk_0", "abc-123_chunk_1"
   */
  id: string;

  /**
   * The actual text content of this chunk
   */
  document: string;

  /**
   * Embedding vector generated by Claude API
   * Dimensions: depends on Claude's embedding model (typically 1024 or 1536)
   */
  embedding: number[];

  /**
   * Metadata for filtering and reconstruction
   */
  metadata: DocumentChunkMetadata;
}

/**
 * Metadata stored with each chunk in ChromaDB
 */
export interface DocumentChunkMetadata {
  /**
   * Parent document ID (references KnowledgeDocument.id)
   */
  documentId: string;

  /**
   * Profile ID (for multi-profile filtering in future)
   */
  profileId: string;

  /**
   * Original filename (for display in search results)
   */
  filename: string;

  /**
   * Chunk index within document (0-based)
   * Used for ordering chunks from same document
   */
  chunkIndex: number;

  /**
   * Character offset where this chunk starts in original document
   * Enables reconstruction or context expansion in future
   */
  startOffset: number;

  /**
   * Character offset where this chunk ends in original document
   */
  endOffset: number;

  /**
   * Timestamp when chunk was created (for debugging)
   * ISO 8601 format
   */
  createdAt: string;
}

/**
 * Result from semantic search query
 */
export interface KnowledgeQueryResult {
  /**
   * Chunk identifier
   */
  chunkId: string;

  /**
   * Parent document identifier
   */
  documentId: string;

  /**
   * Original filename
   */
  filename: string;

  /**
   * Chunk index within document
   */
  chunkIndex: number;

  /**
   * Chunk text content
   */
  content: string;

  /**
   * Cosine similarity score (0-1, higher = more relevant)
   */
  similarity: number;
}

/**
 * Text chunk with position metadata
 */
export interface TextChunk {
  /**
   * Chunk text content
   */
  text: string;

  /**
   * Character offset where chunk starts in original document
   */
  startOffset: number;

  /**
   * Character offset where chunk ends in original document
   */
  endOffset: number;
}

/**
 * File upload data
 */
export interface FileUpload {
  /**
   * File buffer (binary content)
   */
  buffer: Buffer;

  /**
   * Original filename
   */
  filename: string;

  /**
   * MIME type
   */
  mimeType: string;
}

/**
 * Options for document processing
 */
export interface ProcessingOptions {
  /**
   * Maximum tokens per chunk (default: 500)
   */
  chunkSize?: number;

  /**
   * Overlap tokens between chunks (default: 50)
   */
  chunkOverlap?: number;
}

/**
 * Knowledge base configuration (from environment variables)
 */
export interface KnowledgeBaseConfig {
  /**
   * Maximum file size per document (bytes)
   */
  maxFileSizeBytes: number;

  /**
   * Maximum total storage per installation (bytes)
   */
  maxStorageBytes: number;

  /**
   * Filesystem storage root path
   */
  storagePath: string;

  /**
   * Processing timeout (milliseconds)
   */
  processingTimeoutMs: number;

  /**
   * Default chunk size (tokens)
   */
  chunkSizeTokens: number;

  /**
   * Default chunk overlap (tokens)
   */
  chunkOverlapTokens: number;

  /**
   * Default number of chunks to retrieve in queries
   */
  queryTopK: number;

  /**
   * ChromaDB connection settings
   */
  chromadb: {
    host: string;
    port: number;
    timeoutMs: number;
  };
}

/**
 * Knowledge Base error types
 */
export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class StorageLimitError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'StorageLimitError';
  }
}

export class ProcessingError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ProcessingError';
  }
}

export class TimeoutError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'TimeoutError';
  }
}

export class ExtractionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ExtractionError';
  }
}

export class EmbeddingError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'EmbeddingError';
  }
}

export class DeletionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'DeletionError';
  }
}

export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}

