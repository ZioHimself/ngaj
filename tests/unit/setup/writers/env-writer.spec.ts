/**
 * Environment File Writer Tests
 * 
 * Tests for writeEnvFile function that creates the .env file
 * with collected credentials during setup wizard.
 * 
 * @see ADR-011: Installation and Setup Architecture
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { writeEnvFile } from '@ngaj/setup/writers/env-writer.js';
import {
  validSetupConfiguration,
  createMockSetupConfiguration,
  validBlueskyCredentials,
  validAnthropicCredentials,
} from '@tests/fixtures/setup-fixtures';

// Mock fs module
vi.mock('fs', () => ({
  writeFileSync: vi.fn(),
  existsSync: vi.fn(),
  mkdirSync: vi.fn(),
}));

describe('writeEnvFile', () => {
  let mockWriteFileSync: ReturnType<typeof vi.fn>;
  let mockExistsSync: ReturnType<typeof vi.fn>;
  let mockMkdirSync: ReturnType<typeof vi.fn>;

  beforeEach(async () => {
    vi.clearAllMocks();
    const fs = await import('fs');
    mockWriteFileSync = fs.writeFileSync as ReturnType<typeof vi.fn>;
    mockExistsSync = fs.existsSync as ReturnType<typeof vi.fn>;
    mockMkdirSync = fs.mkdirSync as ReturnType<typeof vi.fn>;
    
    // Default: directory exists
    mockExistsSync.mockReturnValue(true);
  });

  describe('file writing', () => {
    it('should write .env file to /data/.env path', async () => {
      await writeEnvFile(validSetupConfiguration);

      expect(mockWriteFileSync).toHaveBeenCalledWith(
        '/data/.env',
        expect.any(String),
        'utf-8'
      );
    });

    it('should include Bluesky credentials in correct format', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain(`BLUESKY_HANDLE=${validBlueskyCredentials.handle}`);
      expect(writtenContent).toContain(`BLUESKY_APP_PASSWORD=${validBlueskyCredentials.appPassword}`);
    });

    it('should include Anthropic credentials in correct format', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain(`ANTHROPIC_API_KEY=${validAnthropicCredentials.apiKey}`);
    });

    it('should include database configuration defaults', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('MONGODB_URI=mongodb://mongodb:27017/ngaj');
      expect(writtenContent).toContain('CHROMA_URL=http://chromadb:8000');
    });

    it('should include application settings', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('PORT=3000');
      expect(writtenContent).toContain('NODE_ENV=production');
    });

    it('should include timestamp comment with completedAt date', async () => {
      const config = createMockSetupConfiguration({
        completedAt: new Date('2026-01-23T14:30:00Z'),
      });

      await writeEnvFile(config);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('# Generated by setup wizard on 2026-01-23T14:30:00.000Z');
    });
  });

  describe('directory creation', () => {
    it('should create directory if it does not exist', async () => {
      mockExistsSync.mockReturnValue(false);

      await writeEnvFile(validSetupConfiguration);

      expect(mockMkdirSync).toHaveBeenCalledWith('/data', { recursive: true });
    });

    it('should not create directory if it already exists', async () => {
      mockExistsSync.mockReturnValue(true);

      await writeEnvFile(validSetupConfiguration);

      expect(mockMkdirSync).not.toHaveBeenCalled();
    });
  });

  describe('content structure', () => {
    it('should include header comment', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('# ngaj Configuration');
    });

    it('should include section comments', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('# Bluesky Credentials');
      expect(writtenContent).toContain('# Anthropic (Claude) API');
      expect(writtenContent).toContain('# Database Configuration');
      expect(writtenContent).toContain('# Application Settings');
    });

    it('should separate sections with blank lines', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      const lines = writtenContent.split('\n');
      
      // Find section headers and verify blank line after credentials
      const blueskyPasswordIndex = lines.findIndex(l => l.startsWith('BLUESKY_APP_PASSWORD='));
      expect(lines[blueskyPasswordIndex + 1]).toBe('');
    });
  });

  describe('multiple platforms', () => {
    it('should write credentials for all platforms in config', async () => {
      // Currently only Bluesky, but test the loop works
      const config = createMockSetupConfiguration({
        platformCredentials: [
          validBlueskyCredentials,
          // Future: could add more platforms here
        ],
      });

      await writeEnvFile(config);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('BLUESKY_HANDLE=');
      expect(writtenContent).toContain('BLUESKY_APP_PASSWORD=');
    });
  });
});
