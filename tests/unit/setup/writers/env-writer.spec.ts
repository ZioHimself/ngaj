/**
 * Environment File Writer Tests
 * 
 * Tests for writeEnvFile function that creates the .env file
 * with collected credentials during setup wizard.
 * 
 * @see ADR-011: Installation and Setup Architecture
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { writeEnvFile, regenerateLoginSecret } from '@ngaj/setup/writers/env-writer.js';
import {
  validSetupConfiguration,
  createMockSetupConfiguration,
  validBlueskyCredentials,
  validAnthropicCredentials,
} from '@tests/fixtures/setup-fixtures';
import { LOGIN_SECRET_PATTERN } from '@ngaj/shared';

// Mock fs module
vi.mock('fs', () => ({
  writeFileSync: vi.fn(),
  readFileSync: vi.fn(),
  existsSync: vi.fn(),
  mkdirSync: vi.fn(),
}));

describe('writeEnvFile', () => {
  let mockWriteFileSync: ReturnType<typeof vi.fn>;
  let mockExistsSync: ReturnType<typeof vi.fn>;
  let mockMkdirSync: ReturnType<typeof vi.fn>;

  beforeEach(async () => {
    vi.clearAllMocks();
    const fs = await import('fs');
    mockWriteFileSync = fs.writeFileSync as ReturnType<typeof vi.fn>;
    mockExistsSync = fs.existsSync as ReturnType<typeof vi.fn>;
    mockMkdirSync = fs.mkdirSync as ReturnType<typeof vi.fn>;
    
    // Default: directory exists
    mockExistsSync.mockReturnValue(true);
  });

  describe('file writing', () => {
    it('should write .env file to /data/.env path', async () => {
      await writeEnvFile(validSetupConfiguration);

      expect(mockWriteFileSync).toHaveBeenCalledWith(
        '/data/.env',
        expect.any(String),
        'utf-8'
      );
    });

    it('should include Bluesky credentials in correct format', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain(`BLUESKY_HANDLE=${validBlueskyCredentials.handle}`);
      expect(writtenContent).toContain(`BLUESKY_APP_PASSWORD=${validBlueskyCredentials.appPassword}`);
    });

    it('should include Anthropic credentials in correct format', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain(`ANTHROPIC_API_KEY=${validAnthropicCredentials.apiKey}`);
    });

    it('should include database configuration defaults', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('MONGODB_URI=mongodb://mongodb:27017/ngaj');
      expect(writtenContent).toContain('CHROMA_URL=http://chromadb:8000');
    });

    it('should include application settings', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('PORT=3000');
      expect(writtenContent).toContain('NODE_ENV=production');
    });

    it('should include timestamp comment with completedAt date', async () => {
      const config = createMockSetupConfiguration({
        completedAt: new Date('2026-01-23T14:30:00Z'),
      });

      await writeEnvFile(config);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('# Generated by setup wizard on 2026-01-23T14:30:00.000Z');
    });
  });

  describe('directory creation', () => {
    it('should create directory if it does not exist', async () => {
      mockExistsSync.mockReturnValue(false);

      await writeEnvFile(validSetupConfiguration);

      expect(mockMkdirSync).toHaveBeenCalledWith('/data', { recursive: true });
    });

    it('should not create directory if it already exists', async () => {
      mockExistsSync.mockReturnValue(true);

      await writeEnvFile(validSetupConfiguration);

      expect(mockMkdirSync).not.toHaveBeenCalled();
    });
  });

  describe('content structure', () => {
    it('should include header comment', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('# ngaj Configuration');
    });

    it('should include section comments', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('# Bluesky Credentials');
      expect(writtenContent).toContain('# Anthropic (Claude) API');
      expect(writtenContent).toContain('# Database Configuration');
      expect(writtenContent).toContain('# Application Settings');
    });

    it('should separate sections with blank lines', async () => {
      await writeEnvFile(validSetupConfiguration);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      const lines = writtenContent.split('\n');
      
      // Find section headers and verify blank line after credentials
      const blueskyPasswordIndex = lines.findIndex(l => l.startsWith('BLUESKY_APP_PASSWORD='));
      expect(lines[blueskyPasswordIndex + 1]).toBe('');
    });
  });

  describe('multiple platforms', () => {
    it('should write credentials for all platforms in config', async () => {
      // Currently only Bluesky, but test the loop works
      const config = createMockSetupConfiguration({
        platformCredentials: [
          validBlueskyCredentials,
          // Future: could add more platforms here
        ],
      });

      await writeEnvFile(config);

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      
      expect(writtenContent).toContain('BLUESKY_HANDLE=');
      expect(writtenContent).toContain('BLUESKY_APP_PASSWORD=');
    });
  });
});

describe('regenerateLoginSecret', () => {
  let mockWriteFileSync: ReturnType<typeof vi.fn>;
  let mockReadFileSync: ReturnType<typeof vi.fn>;
  let mockExistsSync: ReturnType<typeof vi.fn>;
  let mockMkdirSync: ReturnType<typeof vi.fn>;

  beforeEach(async () => {
    vi.clearAllMocks();
    const fs = await import('fs');
    mockWriteFileSync = fs.writeFileSync as ReturnType<typeof vi.fn>;
    mockReadFileSync = fs.readFileSync as ReturnType<typeof vi.fn>;
    mockExistsSync = fs.existsSync as ReturnType<typeof vi.fn>;
    mockMkdirSync = fs.mkdirSync as ReturnType<typeof vi.fn>;
  });

  describe('when .env file exists', () => {
    it('should update existing LOGIN_SECRET line', async () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(
        '# ngaj Configuration\nBLUESKY_HANDLE=test.bsky.social\nLOGIN_SECRET=OLD1-SECR-ET12-3456\nPORT=3000\n'
      );

      const newSecret = await regenerateLoginSecret();

      expect(newSecret).toMatch(LOGIN_SECRET_PATTERN);
      expect(mockWriteFileSync).toHaveBeenCalledWith(
        '/data/.env',
        expect.stringContaining(`LOGIN_SECRET=${newSecret}`),
        'utf-8'
      );
      // Should NOT contain old secret
      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      expect(writtenContent).not.toContain('OLD1-SECR-ET12-3456');
      // Should preserve other content
      expect(writtenContent).toContain('BLUESKY_HANDLE=test.bsky.social');
      expect(writtenContent).toContain('PORT=3000');
    });

    it('should append LOGIN_SECRET if not present in existing file', async () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(
        '# ngaj Configuration\nBLUESKY_HANDLE=test.bsky.social\nPORT=3000\n'
      );

      const newSecret = await regenerateLoginSecret();

      expect(newSecret).toMatch(LOGIN_SECRET_PATTERN);
      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      expect(writtenContent).toContain(`LOGIN_SECRET=${newSecret}`);
      expect(writtenContent).toContain('BLUESKY_HANDLE=test.bsky.social');
    });

    it('should handle file without trailing newline', async () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue('PORT=3000');

      const newSecret = await regenerateLoginSecret();

      const writtenContent = mockWriteFileSync.mock.calls[0][1] as string;
      // Should have newline before LOGIN_SECRET
      expect(writtenContent).toBe(`PORT=3000\nLOGIN_SECRET=${newSecret}\n`);
    });
  });

  describe('when .env file does not exist', () => {
    it('should create new file with only LOGIN_SECRET', async () => {
      // First call for directory check returns true, second for file check returns false
      mockExistsSync.mockImplementation((path: string) => {
        if (path === '/data') return true;
        return false; // File doesn't exist
      });

      const newSecret = await regenerateLoginSecret();

      expect(newSecret).toMatch(LOGIN_SECRET_PATTERN);
      expect(mockWriteFileSync).toHaveBeenCalledWith(
        '/data/.env',
        `LOGIN_SECRET=${newSecret}\n`,
        'utf-8'
      );
    });

    it('should create directory if it does not exist', async () => {
      mockExistsSync.mockReturnValue(false);

      await regenerateLoginSecret();

      expect(mockMkdirSync).toHaveBeenCalledWith('/data', { recursive: true });
    });
  });

  describe('secret format', () => {
    it('should return secret in XXXX-XXXX-XXXX-XXXX format', async () => {
      mockExistsSync.mockReturnValue(false);

      const newSecret = await regenerateLoginSecret();

      expect(newSecret).toMatch(LOGIN_SECRET_PATTERN);
      expect(newSecret.split('-')).toHaveLength(4);
      expect(newSecret.split('-').every(segment => segment.length === 4)).toBe(true);
    });

    it('should generate different secrets on each call', async () => {
      mockExistsSync.mockReturnValue(false);

      const secret1 = await regenerateLoginSecret();
      const secret2 = await regenerateLoginSecret();

      // While theoretically could be the same, probability is ~1.3Ã—10^-26
      expect(secret1).not.toBe(secret2);
    });
  });
});
